<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <title>JSON ‚Üí Figma Clipboard</title>
  <style>
    :root {
      color-scheme: dark;
    }
    body {
      font-family: "SF Pro Text", "Inter", system-ui, -apple-system, sans-serif;
      margin: 0;
      padding: 32px;
      background: #0f1115;
      color: #e6e7eb;
    }
    h1 {
      margin: 0 0 12px;
      font-weight: 700;
    }
    p {
      margin: 0 0 20px;
      color: #9aa0ad;
    }
    textarea {
      width: 100%;
      min-height: 240px;
      background: #131720;
      color: #e6e7eb;
      border: 1px solid #222837;
      border-radius: 10px;
      padding: 14px;
      font-family: "SFMono-Regular", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 14px;
      resize: vertical;
      outline: none;
      box-sizing: border-box;
    }
    button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 12px 18px;
      margin-top: 12px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(120deg, #00c6ff, #0081ff);
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(0, 129, 255, 0.25);
    }
    button:hover {
      transform: translateY(-1px);
      box-shadow: 0 12px 32px rgba(0, 129, 255, 0.32);
    }
    .row {
      display: grid;
      gap: 12px;
      margin-top: 16px;
    }
    .log {
      background: #0c0f17;
      border: 1px solid #1e2433;
      border-radius: 10px;
      padding: 12px;
      margin-top: 16px;
      min-height: 120px;
      font-family: "SFMono-Regular", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      white-space: pre-wrap;
      overflow: auto;
    }
    .inline {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .small {
      color: #768099;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <h1>JSON ‚Üí Figma Clipboard</h1>
  <p>
    ‡∏ß‡∏≤‡∏á JSON node ‡∏à‡∏≤‡∏Å Figma (‡πÄ‡∏ä‡πà‡∏ô‡∏ó‡∏µ‡πà decode ‡πÅ‡∏•‡πâ‡∏ß) ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î ‚Äú‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞ Copy‚Äù ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á meta HTML (fig-kiwi) ‡πÉ‡∏´‡πâ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ß‡∏≤‡∏á‡πÉ‡∏ô Figma ‡πÑ‡∏î‡πâ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
  </p>

  <div class="row">
    <label class="small">‡πÉ‡∏™‡πà JSON ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö object ‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡∏´‡∏£‡∏∑‡∏≠ array ‡∏Ç‡∏≠‡∏á nodeChanges)</label>
    <textarea id="json-input" spellcheck="false" placeholder='{ "type": "FRAME", "name": "Card", "width": 320, "height": 180, "fills": [{ "type": "SOLID", "color": { "r": 0.1, "g": 0.1, "b": 0.1 } }] }'></textarea>
    <div class="inline">
      <button id="btn-run">‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞ Copy</button>
      <span class="small">‡∏à‡∏∞ wrap ‡πÄ‡∏õ‡πá‡∏ô array ‡πÉ‡∏´‡πâ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏ñ‡πâ‡∏≤‡πÄ‡∏õ‡πá‡∏ô node ‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß</span>
    </div>
  </div>

  <div id="log" class="log">‡∏£‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•...</div>
  <div class="row" id="result-box" style="display:none;">
    <label class="small">HTML ‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á (‡∏™‡∏≥‡∏£‡∏≠‡∏á‡πÄ‡∏ú‡∏∑‡πà‡∏≠ copy ‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô)</label>
    <textarea id="result-html" spellcheck="false" readonly></textarea>
  </div>

  <h2 style="margin-top:32px;">‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™ Figma Clipboard (fig-kiwi) ‚Üí JSON</h2>
  <p class="small">
    ‡∏ß‡∏≤‡∏á HTML clipboard ‡∏Ç‡∏≠‡∏á Figma (‡∏°‡∏µ <code>&lt;!--(figma)...(/figma)--&gt;</code>) ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î Decode ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ñ‡∏≠‡∏î‡πÄ‡∏õ‡πá‡∏ô JSON node (‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏™‡πà‡∏á‡∏°‡∏≤)
  </p>
  <div class="row">
    <label class="small">‡∏ß‡∏≤‡∏á Figma clipboard HTML ‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</label>
    <textarea id="figma-html-input" spellcheck="false" placeholder="‡∏ß‡∏≤‡∏á HTML ‡∏à‡∏≤‡∏Å‡∏Ñ‡∏•‡∏¥‡∏õ‡∏ö‡∏≠‡∏£‡πå‡∏î Figma"></textarea>
    <div class="inline">
      <button id="btn-decode">Decode Figma Clipboard</button>
      <span class="small">‡∏î‡∏∂‡∏á base64 ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á <!--(figma)...(/figma)--></span>
    </div>
  </div>
  <div class="row" id="decoded-box" style="display:none;">
    <label class="small">JSON ‡∏ó‡∏µ‡πà‡∏ñ‡∏≠‡∏î‡πÑ‡∏î‡πâ</label>
    <textarea id="decoded-json" spellcheck="false" readonly></textarea>
  </div>

  <script type="module">
    import { createFigmaClipboardHTML } from '/src/lib/figma-encoder.ts';
    import { compileSchema } from 'kiwi-schema';
    import { inflateSync } from 'fflate';
    import { defaultSchema } from '/src/lib/figma-schema.ts';

    const input = document.getElementById('json-input');
    const logEl = document.getElementById('log');
    const btn = document.getElementById('btn-run');
    const resultBox = document.getElementById('result-box');
    const resultHtml = document.getElementById('result-html');
    const figmaHtmlInput = document.getElementById('figma-html-input');
    const btnDecode = document.getElementById('btn-decode');
    const decodedBox = document.getElementById('decoded-box');
    const decodedJson = document.getElementById('decoded-json');

    // Detect file:// and warn (module imports/CORS ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏á‡∏≤‡∏ô)
    if (location.protocol === 'file:') {
      log('‚ö†Ô∏è ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏ú‡πà‡∏≤‡∏ô‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå http/https (‡πÄ‡∏ä‡πà‡∏ô cd webapp && npm run dev ‡πÅ‡∏•‡πâ‡∏ß‡πÄ‡∏õ‡∏¥‡∏î http://localhost:3000/json-clipboard.html) ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ browser ‡∏ö‡∏•‡πá‡∏≠‡∏Ñ import ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ file://');
    }

    function log(message) {
      logEl.textContent = message;
      console.log(message);
    }

    function validateColor(color, path, errors) {
      if (!color || typeof color !== 'object') {
        errors.push(`${path}: color ‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô object`);
        return;
      }
      ['r', 'g', 'b'].forEach((k) => {
        if (typeof color[k] !== 'number' || color[k] < 0 || color[k] > 1) {
          errors.push(`${path}: color.${k} ‡∏Ñ‡∏ß‡∏£‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç 0-1`);
        }
      });
    }

    function hexToColorObj(hex) {
      const cleaned = hex.replace('#', '');
      if (![3, 6].includes(cleaned.length)) return null;
      const full = cleaned.length === 3
        ? cleaned.split('').map(c => c + c).join('')
        : cleaned;
      const num = parseInt(full, 16);
      if (isNaN(num)) return null;
      const r = ((num >> 16) & 255) / 255;
      const g = ((num >> 8) & 255) / 255;
      const b = (num & 255) / 255;
      return { r, g, b, a: 1 };
    }

    function normalizeColors(node) {
      if (!node || typeof node !== 'object') return node;
      // Fills
      if (Array.isArray(node.fills)) {
        node.fills = node.fills.map((f) => {
          if (f && typeof f.color === 'string' && f.color.startsWith('#')) {
            const c = hexToColorObj(f.color);
            if (c) f.color = c;
          }
          return f;
        });
      }
      // Strokes
      if (Array.isArray(node.strokes)) {
        node.strokes = node.strokes.map((s) => {
          if (s && typeof s.color === 'string' && s.color.startsWith('#')) {
            const c = hexToColorObj(s.color);
            if (c) s.color = c;
          }
          return s;
        });
      }
      // Recurse children
      if (Array.isArray(node.children)) {
        node.children = node.children.map((ch) => normalizeColors(ch));
      }
      return node;
    }

    function validateNode(node, path = 'node') {
      const errors = [];

      if (!node || typeof node !== 'object') {
        errors.push(`${path}: ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà object`);
        return errors;
      }

      if (!node.type || typeof node.type !== 'string') {
        errors.push(`${path}: ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ type (FRAME/RECTANGLE/TEXT/...)`);
      }
      if (!node.name || typeof node.name !== 'string') {
        errors.push(`${path}: ‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ name (string)`);
      }

      const type = node.type;

      // Common size check for non-TEXT shapes
      if (type !== 'TEXT') {
        if (typeof node.width !== 'number') {
          errors.push(`${path}: ${type} ‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ width (number)`);
        }
        if (typeof node.height !== 'number') {
          errors.push(`${path}: ${type} ‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ height (number)`);
        }
      }

      // Type-specific checks
      if (type === 'TEXT') {
        if (typeof node.characters !== 'string' || node.characters.length === 0) {
          errors.push(`${path}: TEXT ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ characters`);
        }
        if (typeof node.fontSize !== 'number') {
          errors.push(`${path}: TEXT ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ fontSize (number)`);
        }
        if (!node.fontName || typeof node.fontName.family !== 'string' || typeof node.fontName.style !== 'string') {
          errors.push(`${path}: TEXT ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ fontName {family, style}`);
        }
        if (!Array.isArray(node.fills) || node.fills.length === 0) {
          errors.push(`${path}: TEXT ‡∏Ñ‡∏ß‡∏£‡∏°‡∏µ fills ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£`);
        } else {
          node.fills.forEach((f, idx) => {
            if (f.type === 'SOLID') validateColor(f.color, `${path}.fills[${idx}]`, errors);
          });
        }
      } else {
        if (Array.isArray(node.fills)) {
          node.fills.forEach((f, idx) => {
            if (f.type === 'SOLID') validateColor(f.color, `${path}.fills[${idx}]`, errors);
          });
        }
      }

      // Children
      if (Array.isArray(node.children)) {
        node.children.forEach((child, i) => {
          errors.push(...validateNode(child, `${path}.children[${i}]`));
        });
      }

      return errors;
    }

    function normalizePayload(value) {
      // ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö node ‡πÄ‡∏î‡∏µ‡πà‡∏¢‡∏ß‡∏´‡∏£‡∏∑‡∏≠ array
      if (Array.isArray(value)) return value;
      return [value];
    }

    async function run() {
      if (!btn) {
        console.error('btn-run not found');
        return;
      }
      btn.disabled = true;
      btn.textContent = '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...';
      log('üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏õ‡∏•‡∏á...');
      resultBox.style.display = 'none';
      resultHtml.value = '';
      let data;
      try {
        data = JSON.parse(input.value);
      } catch (err) {
        log('‚ùå JSON ‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: ' + err.message);
        btn.disabled = false;
        btn.textContent = '‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞ Copy';
        return;
      }

      // Normalize color strings (#hex) to rgba objects
      const payload = normalizePayload(data).map((n) => normalizeColors(n));

      // Validation
      const validationErrors = [];
      payload.forEach((n, idx) => {
        validationErrors.push(...validateNode(n, `root[${idx}]`));
      });

      if (validationErrors.length > 0) {
        log('‚ö†Ô∏è ‡∏û‡∏ö‡∏õ‡∏±‡∏ç‡∏´‡∏≤‡πÉ‡∏ô‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á:\n- ' + validationErrors.join('\n- '));
        // ‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πÅ‡∏õ‡∏•‡∏á ‡πÅ‡∏ï‡πà‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡∏Å‡πà‡∏≠‡∏ô
      } else {
        log('‚úÖ ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á JSON ‡∏î‡∏π‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÅ‡∏õ‡∏•‡∏á...');
      }

      try {
        const result = await createFigmaClipboardHTML(payload);
        if (!result.success || !result.html) {
          log('‚ùå ‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: ' + (result.error || 'unknown error'));
          btn.disabled = false;
          btn.textContent = '‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞ Copy';
          return;
        }

        const blob = new Blob([result.html], { type: 'text/html' });
        let copied = false;
        try {
          await navigator.clipboard.write([
            new ClipboardItem({
              'text/html': blob,
              'text/plain': new Blob([''], { type: 'text/plain' })
            })
          ]);
          copied = true;
        } catch (err) {
          // Fallback: try writeText (‡∏à‡∏∞‡πÄ‡∏™‡∏µ‡∏¢ meta ‡πÅ‡∏ï‡πà‡πÉ‡∏´‡πâ copy manual ‡πÑ‡∏î‡πâ)
          try {
            await navigator.clipboard.writeText(result.html);
            log('‚ö†Ô∏è ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÄ‡∏õ‡πá‡∏ô text/plain (meta ‡∏´‡∏≤‡∏¢) ‡πÄ‡∏û‡∏£‡∏≤‡∏∞ clipboard HTML ‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï/‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà https ‡∏´‡∏£‡∏∑‡∏≠ localhost');
            copied = true;
          } catch (err2) {
            log('‚ö†Ô∏è ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏≠‡∏≤‡∏à‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡∏¥‡∏î‡∏ú‡πà‡∏≤‡∏ô localhost/https ‡∏´‡∏£‡∏∑‡∏≠‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï clipboard: ' + err2.message);
          }
        }

        const preview = result.html.slice(0, 220).replace(/\s+/g, ' ');
        if (copied) {
          log('‚úÖ ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß ‡πÑ‡∏õ‡∏ß‡∏≤‡∏á‡πÉ‡∏ô Figma ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢\n\nüì¶ html length: ' + result.html.length + '\nüîç preview: ' + preview + '...');
        }
        resultBox.style.display = 'grid';
        resultHtml.value = result.html;
      } catch (err) {
        log('‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + err.message);
        console.error(err);
      }
      btn.disabled = false;
      btn.textContent = '‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞ Copy';
    }

    if (btn) {
      btn.addEventListener('click', run);
    } else {
      console.error('btn-run not found');
    }

    // ================== Decoder: fig-kiwi HTML -> JSON ==================
    const FIGMA_REGEX = /<!--\(figma\)([\s\S]*?)\(\/figma\)-->/;

    function extractFigBytesFromHtml(html) {
      const match = html.match(FIGMA_REGEX);
      if (!match) throw new Error('‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏™‡πà‡∏ß‡∏ô <!--(figma)...(/figma)-->');
      const base64 = match[1].trim();
      const binStr = atob(base64);
      const bytes = new Uint8Array(binStr.length);
      for (let i = 0; i < binStr.length; i++) bytes[i] = binStr.charCodeAt(i);
      return bytes;
    }

    function decodeKiwiMessage(bytes) {
      const prelude = new TextDecoder().decode(bytes.slice(0, 7));
      if (prelude !== 'fig-kiwi') {
        throw new Error('‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà fig-kiwi clipboard');
      }
      let offset = 8; // skip prelude
      const view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      const version = view.getUint32(offset, true);
      offset += 4;
      const len1 = view.getUint32(offset, true);
      offset += 4 + len1; // skip compressed schema
      const len2 = view.getUint32(offset, true);
      offset += 4;
      const chunk2 = bytes.slice(offset, offset + len2);

      const compiled = compileSchema(defaultSchema);
      const inflated = inflateSync(chunk2);
      const decoded = (compiled).decodeMessage(inflated);
      return { version, decoded };
    }

    function mapNodeChangeToSimple(change) {
      const node = {
        name: change.name,
        type: change.type,
      };
      if (change.transform) {
        node.x = change.transform.m02 || 0;
        node.y = change.transform.m12 || 0;
      }
      if (change.size) {
        node.width = change.size.x;
        node.height = change.size.y;
      }
      if (Array.isArray(change.fillPaints) && change.fillPaints.length) {
        node.fills = change.fillPaints.map(f => ({
          type: 'SOLID',
          color: f.color || { r: 0, g: 0, b: 0, a: 1 },
          opacity: f.opacity ?? 1,
          blendMode: f.blendMode || 'NORMAL'
        }));
      }
      if (Array.isArray(change.strokePaints) && change.strokePaints.length) {
        node.strokes = change.strokePaints.map(s => ({
          type: 'SOLID',
          color: s.color || { r: 0, g: 0, b: 0, a: 1 },
          opacity: s.opacity ?? 1,
          blendMode: s.blendMode || 'NORMAL'
        }));
        if (change.strokeWeight !== undefined) node.strokeWeight = change.strokeWeight;
      }
      if (change.cornerRadius !== undefined) node.cornerRadius = change.cornerRadius;
      if (change.type === 'TEXT') {
        if (change.textData?.characters) node.characters = change.textData.characters;
        if (change.fontSize) node.fontSize = change.fontSize;
        if (change.fontName) node.fontName = change.fontName;
        if (change.lineHeight) node.lineHeight = change.lineHeight;
        if (change.textAlignHorizontal) node.textAlignHorizontal = change.textAlignHorizontal;
        if (change.textAlignVertical) node.textAlignVertical = change.textAlignVertical;
        if (change.textAutoResize) node.textAutoResize = change.textAutoResize;
      }
      // auto layout approx from stack fields
      if (change.stackMode) node.layoutMode = change.stackMode;
      if (change.stackSpacing !== undefined) node.itemSpacing = change.stackSpacing;
      if (change.stackPaddingTop !== undefined) node.paddingTop = change.stackPaddingTop;
      if (change.stackPaddingRight !== undefined) node.paddingRight = change.stackPaddingRight;
      if (change.stackPaddingBottom !== undefined) node.paddingBottom = change.stackPaddingBottom;
      if (change.stackPaddingLeft !== undefined) node.paddingLeft = change.stackPaddingLeft;
      return node;
    }

    function buildTree(nodeChanges) {
      const map = new Map();
      const roots = [];
      nodeChanges.forEach(ch => {
        const key = `${ch.guid.sessionID}:${ch.guid.localID}`;
        map.set(key, { ...mapNodeChangeToSimple(ch), children: [], _parentIndex: ch.parentIndex });
      });
      map.forEach((node) => {
        const p = node._parentIndex;
        delete node._parentIndex;
        if (p && p.guid) {
          const pKey = `${p.guid.sessionID}:${p.guid.localID}`;
          const parent = map.get(pKey);
          if (parent) {
            parent.children = parent.children || [];
            parent.children.push(node);
            return;
          }
        }
        if (node.type !== 'DOCUMENT' && node.type !== 'CANVAS') {
          roots.push(node);
        }
      });
      return roots;
    }

    async function decodeFigmaClipboard() {
      try {
        if (!figmaHtmlInput.value.trim()) {
          log('‚ö†Ô∏è ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ß‡∏≤‡∏á HTML ‡∏à‡∏≤‡∏Å‡∏Ñ‡∏•‡∏¥‡∏õ‡∏ö‡∏≠‡∏£‡πå‡∏î‡∏Å‡πà‡∏≠‡∏ô');
          return;
        }
        const bytes = extractFigBytesFromHtml(figmaHtmlInput.value);
        const { decoded } = decodeKiwiMessage(bytes);
        const tree = buildTree(decoded.nodeChanges || []);
        decodedBox.style.display = 'grid';
        decodedJson.value = JSON.stringify(tree, null, 2);
        log('‚úÖ ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™ clipboard ‡πÅ‡∏•‡πâ‡∏ß');
      } catch (err) {
        log('‚ùå Decode ‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ' + err.message);
        console.error(err);
      }
    }

    if (btnDecode) {
      btnDecode.addEventListener('click', decodeFigmaClipboard);
    }

    // ‡πÉ‡∏™‡πà sample ‡πÄ‡∏•‡πá‡∏Å ‡πÜ ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡πÑ‡∏î‡πâ‡∏ó‡∏±‡∏ô‡∏ó‡∏µ
    input.value = JSON.stringify({
      type: 'TEXT',
      name: 'Sample',
      characters: 'Hello from JSON ‚Üí Figma',
      fontSize: 18,
      fills: [{ type: 'SOLID', color: { r: 1, g: 1, b: 1 }, visible: true }]
    }, null, 2);
  </script>
</body>
</html>
